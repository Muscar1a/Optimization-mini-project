Initialize routes for each vehicle using a heuristic method (e.g., nearest neighbor).

Repeat until convergence or stopping criterion is met:
    For each route:
        Apply 2-opt local search to optimize the route.

    Consider inter-depot relationships:
        Explore possible swaps or reassignment of customers between depots.

    Ensure capacity constraints are satisfied.

    Evaluate the objective function (longest route).

    If improvement is made, continue; otherwise, exit the loop.

Output the optimized solution.


Function: 2OptSwap(route, i, j)
  NewRoute = route[0:i] + Reverse(route[i:j+1]) + route[j+1:]
  Return NewRoute

 while improvement:
        improvement = False
        longest_route_before = calculate_longest_route(routes, distance_matrix)

        for route in routes:
            for i in range(1, len(route) - 1):
                for j in range(i+1, len(route) - 1):
                    new_route = two_opt_swap(route, i, j)
                    new_distance = calculate_route_distance(new_route, distance_matrix)

                    if new_distance < calculate_route_distance(route, distance_matrix):
                        routes[routes.index(route)] = new_route
                        improvement = True

        longest_route_after = calculate_longest_route(routes, distance_matrix)

        if not improvement or longest_route_after >= longest_route_before:
            break

    return routes